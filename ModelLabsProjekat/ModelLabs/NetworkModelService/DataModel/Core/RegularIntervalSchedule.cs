//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version:4.0.30319.42000
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System.Collections.Generic;
using FTN.Common;

namespace FTN.Services.NetworkModelService.DataModel.Core
{
    /// The schedule has time points where the time between them is constant.
    public class RegularIntervalSchedule : BasicIntervalSchedule {

        public RegularIntervalSchedule(long globalId) : base(globalId)
        {
        }
        
        #region endTime
        /// The time for the last time point.
        private System.DateTime? cim_endTime;
        
        private const bool isEndTimeMandatory = false;
        
        private const string _endTimePrefix = "cim";

        public virtual System.DateTime EndTime
        {
            get
            {
                return this.cim_endTime.GetValueOrDefault();
            }
            set
            {
                this.cim_endTime = value;
            }
        }

        public virtual bool EndTimeHasValue
        {
            get
            {
                return this.cim_endTime != null;
            }
        }

        public static bool IsEndTimeMandatory
        {
            get
            {
                return isEndTimeMandatory;
            }
        }

        public static string EndTimePrefix
        {
            get
            {
                return _endTimePrefix;
            }
        }

        #endregion endTime

        #region timeStep
        /// The time between each pair of subsequent regular time points in sequence order.
        private System.Single? cim_timeStep;
        
        private const bool isTimeStepMandatory = false;
        
        private const string _timeStepPrefix = "cim";

        public virtual float TimeStep
        {
            get
            {
                return this.cim_timeStep.GetValueOrDefault();
            }
            set
            {
                this.cim_timeStep = value;
            }
        }

        public virtual bool TimeStepHasValue
        {
            get
            {
                return this.cim_timeStep != null;
            }
        }

        public static bool IsTimeStepMandatory
        {
            get
            {
                return isTimeStepMandatory;
            }
        }

        public static string TimeStepPrefix
        {
            get
            {
                return _timeStepPrefix;
            }
        }

        #endregion timeStep

        #region TimePoints

        List<long> cim_TimePoints = new List<long>();

        public List<long> TimePoints
        {
            get
            {
                return cim_TimePoints;
            }
            set
            {
                cim_TimePoints = value;
            }
        }

        #endregion TimePoints

        public override bool Equals(object obj)
        {
            if (base.Equals(obj))
            {
                RegularIntervalSchedule ris = (RegularIntervalSchedule)obj;
                return ((ris.cim_endTime    == this.cim_endTime) &&
                        (ris.cim_timeStep   == this.cim_timeStep) &&
                        (CompareHelper.CompareLists(ris.cim_TimePoints, this.cim_TimePoints)));
            }
            else
            {
                return false;
            }
        }

        public override int GetHashCode()
        {
            return base.GetHashCode();
        }

        #region IAccess implementation

        public override bool HasProperty(ModelCode property)
        {
            switch (property)
            {
                case ModelCode.RegularIntervalSdle_EndT_:
                case ModelCode.RegularIntervalSdle_TStep_:
                case ModelCode.RegularIntervalSdle_TPs_:
                    return true;

                default:
                    return base.HasProperty(property);
            }
        }

        public override void GetProperty(Property prop)
        {
            switch (prop.Id)
            {
                case ModelCode.RegularIntervalSdle_EndT_:
                    prop.SetValue(EndTime);
                    break;
                case ModelCode.RegularIntervalSdle_TStep_:
                    prop.SetValue(TimeStep);
                    break;
                case ModelCode.RegularIntervalSdle_TPs_:
                    prop.SetValue(TimePoints);
                    break;

                default:
                    base.GetProperty(prop);
                    break;
            }
        }

        public override void SetProperty(Property property)
        {
            switch (property.Id)
            {
                case ModelCode.RegularIntervalSdle_EndT_:
                    cim_endTime = property.AsDateTime();
                    break;
                case ModelCode.RegularIntervalSdle_TStep_:
                    cim_timeStep = property.AsFloat();
                    break;

                default:
                    base.SetProperty(property);
                    break;
            }
        }

        #endregion IAccess implementation	

        #region IReference implementation

        public override bool IsReferenced
        {
            get
            {
                return cim_TimePoints.Count > 0 || base.IsReferenced;
            }
        }

        public override void GetReferences(Dictionary<ModelCode, List<long>> references, TypeOfReference refType)
        {
            if (cim_TimePoints != null && cim_TimePoints.Count > 0 && (refType == TypeOfReference.Target || refType == TypeOfReference.Both))
            {
                references[ModelCode.RegularIntervalSdle_TPs_] = cim_TimePoints.GetRange(0, cim_TimePoints.Count);
            }

            base.GetReferences(references, refType);
        }

        public override void AddReference(ModelCode referenceId, long globalId)
        {
            switch (referenceId)
            {
                case ModelCode.RegularTP_IntervalSdle_:
                    cim_TimePoints.Add(globalId);
                    break;

                default:
                    base.AddReference(referenceId, globalId);
                    break;
            }
        }

        public override void RemoveReference(ModelCode referenceId, long globalId)
        {
            switch (referenceId)
            {
                case ModelCode.RegularTP_IntervalSdle_:

                    if (cim_TimePoints.Contains(globalId))
                    {
                        cim_TimePoints.Remove(globalId);
                    }
                    else
                    {
                        CommonTrace.WriteTrace(CommonTrace.TraceWarning, "Entity (GID = 0x{0:x16}) doesn't contain reference 0x{1:x16}.", this.GlobalId, globalId);
                    }

                    break;

                default:
                    base.RemoveReference(referenceId, globalId);
                    break;
            }
        }

        #endregion IReference implementation

    }
}
